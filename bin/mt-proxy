#!/usr/bin/env ruby

$:<< File.expand_path("../../lib", __FILE__)
require 'mt/proxy'
require 'thor'
require 'json'
require 'net/http'


class CLI < Thor

  desc "status", "status of the proxy servers"
  method_option :redis, type: :string, default: 'redis://127.0.0.1:6379', desc: "redis server"

  def status
    db = redis
    proxies = db.lrange "hosts", 0, -1
    status = proxies.each_with_object({}) do |proxy,info|
      public_address = db.get("#{proxy}:goes_as")
      info[proxy] = { public_address: public_address }
    end
    puts JSON.pretty_generate(status)

  end

  desc "register", "registers a proxy endpoint"
  method_option :redis, type: :string, default: 'redis://127.0.0.1:6379', desc: "redis server"
  method_option :proxy_address, type: :string, desc: "proxy address including port", required: true
  method_option :public_address, type: :string, desc: "public address", required: true
  def register
    redis
    MT::Proxy.register(options[:proxy_address], options[:public_address])
  end

  desc "watchdog", "starts an watchdog that checks the proxy and registers the proxy"
  method_option :redis, type: :string, default: 'redis://127.0.0.1:6379', desc: "redis server"
  method_option :proxy_address, type: :string, desc: "proxy address including port", required: true
  method_option :public_address, type: :string, desc: "public address", required: true
  method_option :url, type: :string, desc: "url to test", required: true
  method_option :interval, type: :numeric, desc: "interval in seconds between checks", default: 10
  method_option :restart_script, type: :string, desc: "restart script"
  def watchdog
    MT::Proxy.check_interval = options[:interval]
    proxy_uri = URI.parse("http://#{options[:proxy_address]}")
    proxy = Net::HTTP::Proxy(proxy_uri.host, proxy_uri.port)
    url = URI(options[:url])

    loop do

      redis(:reload) unless redis.connected?

      begin
        proxy.start(url.host, url.port) do |http|
          response = http.head('/')
          if response.code
            MT::Proxy.register options[:proxy_address], options[:public_address]
          else
            restart "Healthcheck failed #{response.code}"
          end
        end
      rescue => e
        restart e.message
      end

      sleep MT::Proxy.check_interval

    end
  end



  private

  def restart(reason)
    MT::Proxy.unregister options[:proxy_address], options[:public_address]
    if script = options[:restart_script]
      puts "Restarting - #{reason}"
      system(script)
    else
      puts "Failure - #{reason}"
    end
  end

  def redis(reload=false)
    @redis = nil if reload
    @redis ||= begin
      MT::Proxy.redis= Redis.new(url: options[:redis])
      MT::Proxy.redis
    end
  end


end

CLI.start
