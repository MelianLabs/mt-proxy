#!/usr/bin/env ruby

$:<< File.expand_path("../../lib", __FILE__)
require 'mt/proxy'
require 'thor'
require 'json'
require 'net/http'


class CLI < Thor

  desc "status", "status of the proxy servers"
  method_option :redis, type: :string, default: 'redis://127.0.0.1:6379', desc: "redis server"

  def status
    db = redis
    status = {}

    redis.keys("pools:*").each do |pool|
      pool.gsub!(/^pools:/,'')
      proxies = db.lrange pool, 0, -1
      proxies.each_with_object(status) do |proxy,info|
        public_address = db.get("#{proxy}:goes_as")
        next if public_address.nil?
        started_at = db.get("#{proxy}:registered_at").to_i
        restarted_at = Time.at(started_at)

        hosts = Hash[*db.keys("#{proxy}:since:#{started_at}:*:requests").map do |key|
          [ $1, db.get(key).to_i ] if key =~ %r{#{proxy}:since:#{started_at}:(.+):requests}
        end.compact.flatten]

        info[proxy] = {
          public_address: public_address,
          pool: pool,
          restarted_at: "#{restarted_at} (#{Time.current.to_i - started_at} seconds ago)",
          stats: {
            total: {
              requests: db.get("#{proxy}:requests").to_i,
            },
            since_last_restart: {
              total: db.get("#{proxy}:since:#{started_at}:requests").to_i,
              hosts: hosts
            }
          }

        }
      end
    end
    puts JSON.pretty_generate(status)

  end

  desc "console", "stars a shell"
  def console
    db = redis
    pry MT::Proxy
  end

  desc "limits", "manage limits"
  method_option :redis, type: :string, default: 'redis://127.0.0.1:6379', desc: "redis server"
  method_option :set, type: :string, desc: "the hostname"
  method_option :unset, type: :string, desc: "the hostname"
  method_option :requests, type: :numeric, desc: "number of requests"

  def limits
    if options[:set]
      requests = options[:requests].to_i
      if requests == 0
        puts "Number of requests must be > 0"
        return
      end
      redis.set "limits:#{options[:set]}", requests
      return
    end

    redis.del "limits:#{options[:unset]}" and return if options[:unset]
    require 'pp'
    keys = redis.keys "limits:*"
    unless keys.empty?
      limits = Hash[*keys.zip(redis.mget(keys)).map do |(key, limit)|
        [ key.gsub(%r{limits:},''), limit ]
      end.flatten]
      puts limits.to_json
    end

  end



  private

  def redis(reload=false)
    @redis = nil if reload
    @redis ||= begin
      MT::Proxy.redis= Redis.new(url: options[:redis])
      MT::Proxy.redis
    end
  end


end

CLI.start
